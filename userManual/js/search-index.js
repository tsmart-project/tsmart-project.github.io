var gAlphaIndex = [['0',0,0],['1',1,12],['3',13,15],['4',16,22],['5',23,27],['6',28,31],['7',32,33],['8',34,34],['a',35,43],['b',44,59],['c',60,76],['d',77,83],['e',84,87],['f',88,90],['g',91,95],['h',96,99],['i',100,103],['j',104,106],['l',107,112],['m',113,122],['n',123,124],['o',125,128],['p',129,144],['q',145,149],['r',150,156],['s',157,159],['t',160,183],['u',184,190],['v',191,194],['w',195,198],['x',199,199],['z',200,200],['–',201,209],['一',210,212],['上',213,214],['下',215,217],['不',218,219],['中',220,220],['为',221,221],['之',222,222],['也',223,223],['什',224,224],['以',225,225],['使',226,228],['例',229,230],['依',231,231],['保',232,233],['其',234,234],['内',235,236],['准',237,237],['函',238,238],['分',239,239],['单',240,243],['参',244,245],['及',246,246],['可',247,247],['右',248,248],['在',249,252],['堆',253,253],['处',254,254],['复',255,256],['大',257,257],['如',258,261],['它',262,262],['安',263,263],['完',264,264],['对',265,272],['左',273,273],['已',274,274],['常',275,275],['待',276,276],['您',277,277],['或',278,278],['所',279,280],['打',281,281],['执',282,282],['抓',283,283],['抽',284,284],['指',285,295],['推',296,296],['操',297,299],['数',300,300],['整',301,302],['无',303,303],['是',304,310],['最',311,312],['有',313,313],['未',314,315],['本',316,321],['栈',322,322],['样',323,323],['根',324,325],['检',326,327],['死',328,328],['注',329,329],['测',330,330],['涵',331,331],['版',332,332],['特',333,333],['确',334,334],['空',335,335],['第',336,342],['系',343,343],['终',344,344],['缓',345,347],['编',348,349],['缺',350,350],['获',351,351],['表',352,354],['观',355,355],['该',356,356],['软',357,358],['返',359,359],['这',360,362],['进',363,364],['配',365,365],['采',366,366],['释',367,367],['除',368,368],['随',369,371],['静',372,372],['项',373,374],['首',375,377],['，',378,378]];var gWordIndex = [['04版本及以上',[2],[]],['121',[1],[]],['122',[1],[]],['124',[1],[]],['126',[1],[]],['127',[1],[]],['135',[2],[]],['168',[2],[]],['190',[1,3],[]],['191',[1],[]],['192',[2],[]],['195',[1],[]],['196',[1],[]],['32位或64位linux操作系统',[2],[]],['369',[1,3],[]],['3ghz',[2],[[103,[2]]]],['401',[1],[]],['404',[1],[]],['415',[1],[]],['416',[1],[]],['457',[1],[]],['476',[1],[]],['4中则分别存放了单个cwe的检测报告，并且检测报告的排序与检测指令中cwe参数的顺序保持一致。为了获取对目标文件的完整检测结果，我们在这里对output目录下，汇总后的输出报告进行阅读。为了直观的阅读测试报告，这里我们需要用到bugvisualizer工具。',[5],[]],['561',[1],[]],['562',[1],[]],['563',[1],[]],['570',[1],[]],['571',[1],[]],['64位ubuntu',[2],[]],['64位系统环境下不低于4gb',[2],[]],['66ghz',[2],[]],['690',[1],[]],['775',[1],[]],['7及以上',[2],[]],['8及以上。',[5],[]],['a1：为了便于调用不同参数来对原项目进行多次检查，tsmartbd工具在对未编译抓取的项目进行编译抓取和检测时，会在原本项目路径下保存编译抓取的结果。同时编译抓取的过程是依赖于原本项目的make进行的，因此在编译抓取的过程中，该项目已经被make过。',[4],[]],['a2：如果执行了多次测试，并且这多次测试的输出路径是同一个路径，那么这些测试的输出结果会产生交汇，会对后续的测试结果产生污染。因此，如果要重复使用一个路径作为输出路径的话，请确保在每次测试开始之前已经清空该路径下的所有文件。',[4],[]],['a3：输出报告的存放于用户指定的output',[4],[]],['a4：bugvisualizer是在本地服务器上生成报告网页，这将占用本地的8080端口。在使用bugvisualizer之前，请确认该端口没有被占用。',[4],[]],['a5：目前tsmartbd工具只实现了若干种cwe缺陷类型的检测。支持的缺陷类型的编号列表已在前文中给出，请确保使用的cwe类型位于该列表之中。您也可以自行撰写配置文件来实现对其他cwe类型或者自定义要求的检测。',[4],[]],['add',[5],[]],['address',[1],[]],['after',[1],[[84,[1]],[90,[1]]]],['always',[1],[[88,[1]],[165,[1]]]],['based',[1],[[45,[1]]]],['buffer',[1],[[127,[1]],[128,[1]],[185,[1]],[186,[1]]]],['bug',[2],[[194,'-',[2]]]],['bugvisualizer',[2,3],[]],['bugvisualizer工具的使用说明',[2],[]],['bugvisualizer工具的入口',[2],[]],['bugvisualizer工具的网页模板',[2],[]],['bugvisualizer模块',[5],[]],['bugvisualizer的执行命令',[5],[]],['bugvisualizer的执行命令2',[5],[]],['bugvisualizer的网页展示',[5],[]],['build',[2,3],[[60,'-',[2]]]],['buildcapture',[2],[]],['buildcapturestart',[2],[]],['buildcapture工具模块',[5],[]],['buildcapture工具的入口。',[2],[]],['capture',[2],[]],['captured',[3],[]],['clean。随后删除该目录下的',[4],[]],['clean命令。随后在grep目录下按下ctrl',[5],[]],['code',[1],[]],['common',[1],[[195,[1]]]],['conf',[3],[]],['config',[3],[]],['config。',[3],[]],['config文件夹',[2],[]],['conversion',[1],[[86,[1]]]],['core',[2],[]],['core2',[2],[[83,[2]]]],['cwe',[1,3],[]],['cwe一项的参数替换为',[3],[[68,'-',[3]]]],['cwe后连接需要应用的cwe类型编号，最后的',[5],[[126,'-',[5]]]],['cwe类型',[1],[]],['dead',[1],[[64,[1]]]],['dereference',[1],[]],['descriptor',[1],[]],['divide',[1],[]],['docx',[2],[]],['double',[1],[[90,[1]]]],['duo及以上',[2],[]],['effective',[1],[[109,[1]]]],['enumeration（常见缺陷枚举）',[1],[]],['error',[1],[]],['expression',[1],[[43,[1]]]],['false',[1],[]],['file',[1,3],[[79,[1]]]],['free',[1],[]],['git',[2],[]],['grep测试报告展示',[5],[]],['grep项目的抓取检测命令',[5],[]],['grep项目的抓取检测输出',[5],[]],['grep项目的文件组织结构',[5],[]],['hanle',[1],[[42,[1]]]],['heap',[1],[[44,'-',[1]]]],['home',[5],[]],['h显示隐藏文件，删除',[5],[]],['id不存在？',[4],[]],['improper',[1],[[155,[1]]]],['integer',[1],[[128,[1]],[186,[1]]]],['intel',[2],[[71,[2]],[72,[2]]]],['jar',[2,3],[[168,[3]],[201,[3]],[202,[3]],[207,[3]]]],['java',[2,3],[[204,[3]]]],['jdk版本8及以上',[2],[]],['leak',[1],[]],['lib文件夹',[2],[]],['lifetime',[1],[]],['list',[3],[]],['list指定了将要用于检测的cwe缺陷类型的列表，例如',[3],[]],['list指定了需要用于检查的cwe缺陷的类型编号的列表；',[3],[]],['make',[3],[[203,[3]]]],['makefile文件夹。',[4],[]],['makefile文件夹。最后进入要使用的output目录，删除其中所有文件。',[5],[]],['makefile文件夹下，以便于后续分析和检测的进行。其操作方法如下：',[3],[]],['makefile文件夹；',[3],[]],['make是必需参数，build',[3],[]],['manual',[3],[]],['manual后紧接待检测的文件的路径，',[5],[[75,'-',[5]]]],['memory',[1],[[107,[1]]]],['missing',[1],[[152,[1]]]],['namelist',[3],[]],['null',[1],[[139,[1]]]],['output',[3],[]],['output指定了检测结果的输出目录。',[5],[]],['over',[1],[[150,'-',[1]]]],['overflow',[1],[]],['path',[3],[]],['path下，如果该参数没有被指定，那么默认的输出路径是tsmartbd工具存放目录下的output文件夹中。',[4],[]],['path指定了待检测的c文件的路径；',[3],[]],['path指定了检测报告的输出目录的路径。',[3],[]],['path指定了检测结果报告的存放目录，一般为输出目录output下的result',[3],[]],['path指定了检测结果报告的输出目录。',[3],[]],['path指定了用于展示检测结果的网页的模板的路径。bugvisualizer提供了一个自带的模板，其存放于bugvisualizer目录下的webinspector',[3],[]],['path指定了编译抓取结果的路径，该路径一般是项目源代码所在路径下的',[3],[]],['path指定了被检测文件',[3],[]],['path指定了需要编译抓取的项目所保存的路径；',[3],[]],['pointer',[1],[[78,[1]]]],['process',[3,4,5],[]],['project',[3],[]],['project后的参数是被检测文件所存放的文件夹。',[5],[[198,'-',[5]]]],['python',[2],[]],['python版本2',[2],[]],['q1：在对未编译项目进行编译抓取以及检测的时候，为什么第一次成功了，但是第二次却提示失败？',[4],[]],['q2：为什么提示检测成功，也输出了报告，但是实际读取时发现报告存在各种问题？',[4],[]],['q3：为什么我找不到测试报告的输出路径？',[4],[]],['q4：为什么bugvisualizer生成测试报告的展示网页失败了？',[4],[]],['q5：为什么提示cwe',[4],[[100,[4]]]],['read',[1],[]],['readme',[2],[]],['release',[1],[]],['report',[3],[]],['report后紧接的是测试结果的汇总报告的存放目录。',[5],[[142,'-',[5]]]],['resource',[1],[[157,[1]]]],['return',[1],[[191,[1]]]],['shutdown',[1],[]],['signed',[1],[[70,[1]]]],['stack',[1],[[44,'-',[1]],[192,[1]]]],['task',[3],[]],['taskname',[3],[]],['tasks',[3],[]],['template文件夹。',[3],[]],['testcase',[5],[]],['true',[1],[]],['tsmart',[2],[]],['tsmartanalyse',[2],[]],['tsmartanalyze',[3],[]],['tsmartbd',[2],[]],['tsmartbd主要提供了一个软件静态分析的入口。用户需要指定待检测的项目的路径，需要满足的编码规范（即需要检测缺陷类型），以及检测报告的输出路径。之后tsmartbd工具会按照用户指定的参数，自动地对待检测项目进行分析检测，并且生成一份便于阅读的检测报告。',[1],[]],['tsmartbd如何工作',[0,1],[]],['tsmartbd对c语言源代码文件检查方式的一种。',[1],[]],['tsmartbd工具一共包括代码缺陷静态分析工具tsmartbd本体、辅助抓取工具buildcapture、检测报告阅读工具bugvisualizer，共计3个模块。开始安装和使用之前，请确认三个模块是否完备。',[2],[]],['tsmartbd工具会分析程序代码中所有的入口函数，进而取寻找问题。接下来进入bugvisualizer工具，来观察输出报告。由于缺陷的发生与程序的入口有关，因此这里不能直接进入总报告中，直接观察错误目录。tsmartbd工具为每个入口的测试报告单独生成了一个文件夹，如下图所示：',[5],[]],['tsmartbd工具依赖于命令行执行，因此在实际使用中需要指定各类参数。下表给出了tsmartbd工具可以接受的完整参数列表：',[3],[]],['tsmartbd工具对于复合项目的编译抓取接口。',[2],[]],['tsmartbd工具模块',[5],[]],['tsmartbd工具的整体入口，在该入口下设置不同的参数，即可完成各种检测。',[2],[]],['tsmartbd性能',[1],[]],['tsmartbd是一个分析代码缺陷的静态分析工具，可以用于c语言编写的程序源代码进行检测分析，从而给出一个缺陷分析报告。',[1],[]],['tsmartbd有关定义',[0,1],[]],['tsmartbd的性能',[0],[]],['tsmartbuild',[2],[]],['unchecked',[1],[[156,[1]]]],['under',[1],[[150,'-',[1]]]],['underflow',[1],[]],['uninitialized',[1],[[192,[1]]]],['unsigned',[1],[[70,[1]]]],['unused',[1],[[192,[1]]]],['use',[1],[[42,[1]]]],['value',[1],[]],['variable',[1],[[41,[1]]]],['version命令，观察当前系统的java版本是否是1',[5],[]],['visualizer',[2],[]],['weakness',[1],[[85,[1]]]],['web',[3],[]],['webinspector文件夹',[2],[]],['web则是bugvisualizer使用的默认模板。执行该命令之后，会自动打开浏览器，以网页的方式展示出测试结果，如下图所示：',[5],[]],['xml文件；',[3],[]],['zero',[1],[]],['–build',[3],[]],['–captured',[3],[]],['–cwe',[3],[]],['–jar',[3],[[47,[3]],[168,[3]]]],['–output',[3],[]],['–project',[3],[]],['–report',[3],[]],['–task',[3],[]],['–web',[3],[]],['一种国际范围内免费使用的一套统一的，可度量的软件缺陷描述体系。',[1],[]],['一种用于收集计算机程序在不同点的计算值的分析方法。',[1],[]],['一种程序分析中的理论方法，基于有序集合（特别是格）上的单调函数，以及计算程序语义的可靠近似。',[1],[]],['上述准备工作确认无误之后，可以进入下一步。',[5],[]],['上述模块可以通过以下git地址进行获取：',[2],[]],['下图给出了一个tsmartbd的实际使用场景：',[1],[]],['下方一栏展示了被测试文件的代码。',[5],[]],['下表给出了各个模块中，重要的文件夹与文件的作用。在您使用前，可以参考下表，以确认工具模块的完整性。',[2],[]],['不低于2gb',[2],[]],['不低于4gb',[2],[]],['中央上方一栏展示了检测的所有的缺陷，给出了缺陷的编号，严重度，可能性，缺陷类别。选择其中任意一个缺陷，path栏和code栏会进行对应的跳转。',[5],[]],['为必备参数，c',[3],[]],['之后进入tsmartbd模块所在目录，打开终端，执行下列命令：',[5],[]],['也是必需参数，cwe',[3],[]],['什么是tsmartbd',[0,1],[]],['以下也将该描述体系内的一种缺陷简称为cwe。',[1],[]],['使用了未初始化的变量',[1],[]],['使用模板',[3],[]],['使用结束后未释放文件解析器',[1],[]],['例如我们现在想关注函数返回栈上的临时变量的问题，可以选择第3个缺陷id，此时左下角的path路径会更新。新的path路径说明了触发这个问题时，整个程序的执行流程。我们再选中最后一行，这样可以得到直接触发问题的语句所在地点。',[5],[]],['例如，执行以下命令：',[5],[]],['依据可编译项目中的makefile文件，对于目标项目进行编译。',[1],[]],['保存了tsmartbd工具在执行过程中所需要使用的各种外部依赖库。',[2],[]],['保存了tsmartbd工具对于各种检测所预设的参数和配置。',[2],[]],['其中output目录下存放了汇总后的输出报告。而output',[5],[]],['内存泄漏',[1],[]],['内存资源释放不正确',[1],[]],['准备工作',[0,2],[]],['函数返回将被释放的栈地址',[1],[]],['分析结果的目录结构',[5],[]],['单个文件检查',[3],[]],['单文件检查',[1],[]],['单文件检查示例',[0,5],[]],['单文件检测的命令行输出',[5],[]],['参数含义',[3],[]],['参数选项',[3],[]],['及以上',[2],[]],['可用硬盘空间',[2],[]],['右上方一栏提供了过滤器，允许筛选缺陷的类型。',[5],[]],['在实际测试过程中，tsmartbd工具能够支持对百万行及以内的c语言软件项目的检测。',[1],[]],['在确认上述项目的模块均完备无误之后，下一步需要确认当前系统的编译环境。打开终端，执行java',[5],[]],['在终端下执行命令：',[3],[]],['在观察测试报告的时候，需要进入对应入口的文件夹来进行阅读。',[5],[]],['堆缓存区上溢出',[1],[]],['处理器',[2],[]],['复合项目检查',[1],[]],['复合项目检查示例',[0,5],[]],['大于2gb',[2],[]],['如前文所述，tsmartbd工具的缺陷类型是基于cwe设计的。其中，tsmartbd主要涵盖了共计6大类运算、指针缺陷的分析，以及3大类不可达代码、死代码的缺陷分析。下表给出cwe标准下，tsmartbd工具所支持的缺陷类型。',[1],[]],['如图所示，grep项目的编译依赖于其中的makefile。因此tsmartbd工具可以用于检测该项目。',[5],[]],['如图所示，选中path的最后一行后，提示了对于行int',[5],[]],['如当某一条具体的程序执行路径会触发该缺陷时，该执行路径就构成了一个反例。',[1],[]],['它可以被看做是对计算机程序的抽象分析，并且能在不进行所有计算的前提下获取语义信息。',[1],[]],['安装方法',[0,3],[]],['完整参数列表',[0,3],[]],['对于具有makefile文件的c语言程序项目进行检查，编译抓取得到需要检查的所有文件。',[1],[]],['对于单个独立的c文件进行检测，依据预设的参数要求观察其是否具有潜在的缺陷，并且将其汇报出来。',[1],[]],['对于单个的c语言文件进行分析检测；',[1],[]],['对于尚未执行编译抓取的c语言项目进行编译抓取，并且再对其编译抓取的结果进行分析检测；',[1],[]],['对于已经编译抓取的c语言项目进行分析检测；',[1],[]],['对于某种缺陷而言，其反例就是该缺陷触发的一种具体场景。',[1],[]],['对可能为null的函数返回值不进行检查',[1],[]],['对同一空间多次释放',[1],[]],['左侧一列中，第一栏project展示了该目录下的所有c语言文件。第二栏path展示了触发所选择的缺陷的执行流程，并且单击其中的任意一行，右侧的代码框将自动跳转到对应位置。',[5],[]],['已抓取的复合项目的检测',[3],[]],['常见问题解答',[0,4],[]],['待检测项目规模',[1],[]],['您可以点击下表中cwe缺陷的名称，以查看cwe官方的缺陷定义页面。',[1],[]],['或者被检测项目',[3],[]],['所以当再次对该项目进行编译抓取之前，需要清除上一次编译抓取所带来的副作用。其具体的操作方法是：进入原本项目的存放路径，打开终端，并执行make',[4],[[62,[4]]]],['所存放的文件夹的路径；',[3],[]],['打开bugvisualizer文件夹，并在这个目录下打开终端执行，下列命令：',[5],[]],['执行成功后，看到如下输出：',[5],[]],['抓取编译过程中以及编译完成后所产生的代码文件，以供后续的检查。',[1],[]],['抽象分析',[1],[]],['指定操作：单个文件的检测',[3],[]],['指定操作：只对选中的task进行检测',[3],[]],['指定操作：复合项目的检测',[3],[]],['指定操作：将要使用的cwe类型的列表',[3],[]],['指定操作：显示编译抓取结果的task列表',[3],[]],['指定操作：进行编译抓取',[3],[]],['指定路径：将要检查的源文件路径',[3],[]],['指定路径：测试结果报告的输出路径',[3],[]],['指定路径：编译抓取结果的存放路径',[3],[]],['指定路径：需要使用的检测配置文件路径',[3],[]],['指定路径：需要编译抓取的项目的路径',[3],[]],['推荐配置',[2],[]],['操作方法',[0,3],[]],['操作示例',[0,5],[]],['操作系统',[2],[]],['数据流分析',[1],[]],['整型计算向上溢出',[1],[]],['整型计算向下溢出',[1],[]],['无符号类型转化为有符号类型的异常',[1],[]],['是可选参数，output',[3],[]],['是可选参数，tasks指定了将要检查的task的序号。如果不指定该参数，那么将检查目录下所有的task；',[3],[]],['是必备参数，cwe',[3],[]],['是必需参数，captured',[3],[]],['是必需参数，project',[3],[]],['是必需参数，report',[3],[]],['是必需参数，web',[3],[]],['最低配置',[2],[]],['最后我们获得了一个测试报告：',[5],[]],['有符号类型转化为无符号类型的异常',[1],[]],['未使用的变量',[1],[]],['未抓取的复合项目的编译抓取与检测',[3],[]],['本功能主要用于针对单个c文件的检查。目标c文件中可以含有引用的外部头文件或者系统库头文件，它们在分析时都会被自动展开。操作方法如下：',[3],[]],['本功能是对目标源代码文件（或者是目标项目）完成检测之后，将测试报告以网页的方法清晰的展示，以便于用户理解。其操作方法如下：',[3],[]],['本功能用于具有makefile的c语言编写的复合项目的编译抓取。能够将编译抓取的结果保存在原项目路径下的',[3],[]],['本功能用于已经编译抓取完毕的c语言编写的复合项目的编译抓取。操作方法如下：',[3],[]],['本工具在针对上述缺陷类型的检测，在sard、juliet等测试集的对应子集上，达到了如下标准：对于所有的缺陷类型，分析漏报率不高于10',[1],[]],['本部分将结合实际案例的分析检测流程来说明tsmartbd工具的操作方法。',[5],[]],['栈缓存区上溢出',[1],[]],['样例代码的检测命令',[5],[]],['根据实际需求的不同，tsmartbd的功能可以大致分为以下3种：',[1],[]],['根据这个信息就能较为轻松的修复程序源代码中存在的问题。',[5],[]],['检测报告的目录结构',[5],[]],['检测结果精度',[1],[]],['死代码',[1],[]],['注意：为了防止不必要的编码错误产生，请确保解压路径中尽量不要出现中文。',[3],[]],['测试代码',[5],[]],['涵盖缺陷类型',[1],[]],['版本要求',[2],[]],['特别的，如果不想使用tsmartbd中预设的cwe选项，而想要使用自己设计的检测配置。可以将',[3],[[74,'-',[3]]]],['确认当前java版本',[5],[]],['空指针引用',[1],[]],['第一项',[3],[[119,'-',[3]]]],['第一项–build',[3],[]],['第一项–captured',[3],[]],['第一项–report',[3],[]],['第三项',[3],[[125,'-',[3]],[160,'-',[3]],[196,'-',[3]]]],['第二项',[3],[[73,'-',[3]],[141,'-',[3]]]],['第四项',[3],[[125,'-',[3]]]],['系统配置',[0,2],[]],['终端信息提示4个cwe的检测均已完毕，并且成功地将结果输出到我们指定的目录之中。进入该输出目录可以看到如下文件：',[5],[]],['缓存区下溢出',[1],[]],['缓存区读取超过上界',[1],[]],['缓存区读取超过下界',[1],[]],['编译抓取',[1],[]],['编译环境',[2],[]],['缺陷的详细信息查看',[5],[]],['获取tsmartbd工具的压缩包之后，在合适的目录下解压即可。',[3],[]],['表示了将要应用190和369两种cwe；',[3],[]],['表达式永假',[1],[]],['表达式永真',[1],[]],['观察测试结果',[3],[]],['该体系内每一种缺陷都具有独立的编号和与之对应的名称和定义。',[1],[]],['软件依赖',[0,2],[]],['软件项目的编写过程中，有时候代码虽然能够通过编译器的编译和小规模的测试，但是其中仍然可能存在一些隐患。通过程序分析，在这些隐患产生影响之前将其修复，是一个非常具有实际意义的工作。用户可以通过使用tsmartbd对编写的源代码进行分析，并且根据反馈报告对源代码进行修改。如此反复的迭代，就可以逐步消除软件项目中源代码的潜在缺陷，从而提高代码的准确性和稳定性。',[1],[]],['返回首页',[1,2,3,4,5],[]],['这就说明了本行中的函数返回值可能存在问题。因此可以将问题定位到add函数的本次调用之中。',[5],[]],['这里将其保存为：',[5],[]],['这里我们打算对grep项目进行编译抓取和检测，因此在开始之前，首先要确保grep项目之前的编译结果已经被清除。在grep项目下打开终端，执行make',[5],[[63,[5]]]],['进入bugvisualizer的所在目录下，打开终端；',[3],[]],['进入tsmartbd所在的路径下，打开终端；',[3],[]],['配置工作',[0,5],[]],['采用程序的控制流图来确定对于变量的一次赋值可能传播到程序的哪些部分。',[1],[]],['释放之后再次使用该地址',[1],[]],['除0风险',[1],[]],['随后依据预设的参数要求对它们进行逐一检查，并且将检查到的缺陷汇报出来。',[1],[]],['随后我们开始对这个文件进行检查。首先进入tsmartbd模块所在目录，打开终端。依照上文所述，执行下列命令：',[5],[]],['随后终端会依次输出抓取信息和分析信息，运行成功后，输出结果如下图所示。',[5],[]],['静态分析是指在不运行代码的方式下，通过语法分析、词法分析、控制流、数据流分析等技术对程序代码进行扫描，从而验证程序代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。',[1],[]],['项目文件准备',[0,2],[]],['项目组织结构',[0,2],[]],['首先工具模块获取和安装的部分，和单文件的检查流程一致，在此不再复述。直接进入检查部分。我们准备了grep项目作为待检测项目，grep项目的文件组织结构如下图所示：',[5],[]],['首先我们准备一个需要检查的测试案例：',[5],[]],['首先获取tsmartbd工具之后，在一个不含中文字符的路径下进行解压。得到了3个模块，分别如下图所示：',[5],[]],['，误报率低于5',[1],[]]];